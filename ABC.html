<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Inference with ABC</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="mfiidd.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">MFIIDD 2023</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="introduction.html">Introduction</a>
</li>
<li>
  <a href="mcmc.html">MCMC</a>
</li>
<li>
  <a href="mcmc_diagnostics.html">Diagnostics</a>
</li>
<li>
  <a href="play_with_seitl.html">Modelling interlude</a>
</li>
<li>
  <a href="mcmc_and_model_comparison.html">Model comparison</a>
</li>
<li>
  <a href="pmcmc.html">Particle MCMC</a>
</li>
<li>
  <a href="ABC.html">ABC</a>
</li>
<li>
  <a href="further_methods.html">Further methods</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="contact.html">
    <span class="fa fa-envelope-o"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/sbfnk/mfiidd">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Inference with ABC</h1>

</div>


<div id="objectives" class="section level1">
<h1>Objectives</h1>
<p>The aim of this practical is to use Approximate Bayesian Computation (ABC) to circumvent the need for a tractable likelihood function when fitting your model. More specifically, you will</p>
<ol style="list-style-type: decimal">
<li>write some functions to evaluate summary statistics</li>
<li>use the summary statistics to calculate a distance between model runs and the data</li>
<li>approximate the SEITL model posterior using ABC rejection algorithm</li>
</ol>
<p>To illustrate ABC, you are again going to fit the <a href="play_with_seitl.html">SEITL model</a> to the Tristan da Cunha epidemics. Although in this case we do have a tractable likelihood function, you may have noticed that it is computationally costly to evaluate with the particle filter for the stochastic SEITL model (i.e., it takes a long time to run), so ABC could be an attractive alternative. Running and evaluating pMCMC and ABC on this same data set also gives us the chance to compare the two approaches.</p>
</div>
<div id="background" class="section level1">
<h1>Background</h1>
<p>There are two approximation steps at the core of ABC:</p>
<ul>
<li>it replaces observations with summary statistics. Unless these summary statistics are <a href="http://en.wikipedia.org/wiki/Sufficient_statistic">sufficient</a>, this leads to a possibly less informative posterior density.</li>
<li>we are accepting simulations that are within an <em>acceptance window</em> of the data. Unless the acceptance tolerances are equal to 0, this leads to biased samples from the posterior.</li>
</ul>
<p>On the other hand, we have seen in a previous session that MCMC provides unbiased samples from the true posterior at little cost for the deterministic SEITL model. You will end this session by fitting this deterministic model with ABC and assess the accuracy of your ABC posterior distribution by comparing it with the true posterior.</p>
<p>As before, you can load the stochastic SEITL model and the Tristan da Cunha data set with</p>
<pre class="r"><code>data(models)
data(fluTdc1971)</code></pre>
<p>Once again, you can plot the Tristan da Cunha data with</p>
<pre class="r"><code>plotTraj(data = fluTdc1971)</code></pre>
<p><img src="figure/ABC/ABC_plot_TdC_data-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="summary-statistics" class="section level1">
<h1>Summary statistics</h1>
<p>First of all, you need to define a set of summary statistics for the time series. Have a look at the figure above and think of statistics that would describe the data, and capture the features you want to capture. Finally, code at least two functions that take a trajectory (with an <code>obs</code> column containing the observations) as input and return the values of your summary statistics.</p>
<pre class="r"><code>traj &lt;- fluTdc1971

# a function that takes one parameter:
# - traj: a (model or data) trajectory of observations
my_summaryStat1 &lt;- function(traj) {
  # calculate summary statistic using the &quot;obs&quot; column in traj
}

# test
ss1.data &lt;- my_summaryStat1(traj)

# write other summary statistics</code></pre>
<p>If you have trouble coding these up yourself, have a look at some of our <a href="sumstat_examples.html">examples</a>.</p>
<p>Test how your summary statistics vary with a single set of parameters. You can use the <strong>R</strong> function <code>replicates</code>, which calls the same function a specified number of times. For example, to call the <code>ssSize</code> function from the <a href="sumstat_examples.html">examples</a> (which calculates final size) on 100 generated observation trajectories, you can use</p>
<pre class="r"><code>theta &lt;- c(R_0 = 2, D_lat = 2, D_inf = 2, alpha = 0.9, D_imm = 13, rho = 0.85)
initState &lt;- c(S = 250, E = 0, I = 4, T = 0, L = 30, Inc = 0)
hist(
  replicate(100, ssSize(
    rTrajObs(seitlStoch, theta, initState, fluTdc1971$time)
  )),
  xlab = &quot;summary statistic&quot;
)</code></pre>
<p><img src="figure/ABC/size_hist-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>These are stochastic simulations so of course your histogram will look different. If you created your own function for summary statistics (e.g., <code>my_summaryStat1</code>), replace <code>ssSize</code> in the plot command with that one and test how it varies over different simulation runs. We suggest that you try a few summary statistics to get a feeling for how they vary across simulations.</p>
<p>The last command is easiest read from the inside out: <code>rTrajObs</code> with the given arguments produces an observation trajectory from the <code>seitlStoch</code> model, <code>ssSize</code> calculates the final size (i.e., total number of people infected) for such a trajectory, <code>replicates</code> does it 100 times and <code>hist</code> plots the outcome (i.e., the replicates of the final size) as a histogram. Depending on the summary statistic you choose, you might see quite a large amount of variation in the outcome of the summary statistic even with a single set of parameters. This might be a problem later when you define an acceptance window: if it is chosen too large, there is a risk that parameter values are accepted indiscriminately. If it is too small, the acceptance will be low and, consequently, many simulation runs wasted because even good parameter sets will often miss the acceptance window.</p>
<p>Do you think your summary statistics are <a href="http://en.wikipedia.org/wiki/Sufficient_statistic">sufficient</a>?</p>
</div>
<div id="distance-between-observed-and-simulated-summary-statistics" class="section level1">
<h1>Distance between observed and simulated summary statistics</h1>
<p>The second step is to compare your data with your simulation using a function that computes the distance between your observed and simulated summary statistics. In the most general case, you will want to write a distance function for each summary statistic. Here, let’s write a single function that calculates the distance between all summary statistics and returns either a single (e.g., mean) distance or a vector of distances.</p>
<pre class="r"><code># a function that takes 5 arguments:
# - sumStats: a list of functions to calculate summary statistics
# - dataObs: the trajectory of observations (data)
# - modelObs: a trajectory of simulated observations (model)
my_distance &lt;- function(sumStats, dataObs, modelObs) {
  ## start for() loop over all summary stats in the list sumStats

  # calculate the distance (e.g., absolute difference, relative
  # difference, squared distances etc)

  ## end for () loop

  # combine distances (via sum, mean, or others)

  # return an overall distance between the model and data
  # trajectories in terms of the summary statistics. E.g., a vector
  # of distances or a mean distance
}</code></pre>
<p>If you have any trouble writing a function for the distance, have a look at our <a href="distance_examples.html">examples</a>.</p>
<p>Test that your summary distance function returns a sensible value (here, we have assigned the <code>ssMeanRelDistance</code> from the examples to <code>my_distance</code>.</p>
<pre class="r"><code>simu &lt;- rTrajObs(seitlStoch, theta, initState, fluTdc1971$time)
ssMeanRelDistance(
  sumStats = list(ssSize, ssMax),
  dataObs = fluTdc1971,
  modelObs = simu
)</code></pre>
<pre><code>## [1] 0.4716653</code></pre>
<p>Again, you can change <code>ssMeanRelDistance</code> to your own <code>my_distance</code> function or one from the <a href="distance_examples.html">examples</a>, and try different things for the list of summary statistics (including more or less than two summary statistics).</p>
<p>You can then test the distribution of distances of the summary statistics from model runs to the summary statistic on the data, in the same way as we did before with the distribution of summary statistics. You can use <code>computeDistanceAbc</code> function provided in the <code>fitR</code> package does the leg work for you. It computes the distance between a <code>fitmodel</code> and the <code>data</code> for a single simulation using a given parameter vector <code>theta</code> and initial state <code>initState</code>. Have a look at the code of <code>computeDistanceAbc</code>; all it does is generate a simulated observation trajectory and evaluate the distance using a function passed as an argument. We can test it using</p>
<pre class="r"><code>computeDistanceAbc(
  sumStats = list(ssSize, ssMax),
  distanceAbc = ssMeanRelDistance,
  fitmodel = seitlStoch,
  theta = theta,
  initState = initState,
  data = fluTdc1971
)</code></pre>
<pre><code>## [1] 0.9675055</code></pre>
<p>Again, you can change the list of summary statistics (<code>ssSize</code>, <code>ssMax</code>) and the distance function (<code>ssMeanRelDistance</code>) with your own ones, or other ones from the <a href="sumstat_examples.html">examples</a>.</p>
<p>The returned distance is the outcome of a single simulation run, so you will get a different result here, which will also depend on your choice of distance function and summary statistics.</p>
<p>To plot the distribution of distances from the data for a single set of parameter values <code>theta</code>, you can again use <code>replicate</code>.</p>
<pre class="r"><code>hist(
  replicate(100, computeDistanceAbc(
    sumStats = list(ssSize, ssMax),
    distanceAbc = ssMeanRelDistance,
    fitmodel = seitlStoch,
    theta = theta,
    initState = initState,
    data = fluTdc1971
  )),
  xlab = &quot;distance&quot;
)</code></pre>
<p><img src="figure/ABC/distances_plot-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Again, these are stochastic simulations so your histogram will look different, and again you can test this with different summary statistics (including more, or fewer) and distance functions. How widely are the distances distributed for a single set of parameters? This should give you an indication for a reasonable acceptance window. Ideally, you want to have summary statistics that vary a lot between parameter values (so the acceptance window can distinguish between good or bad fits), but not so much within parameter values (so you don’t have to reject many runs from good parameters). Finding the right combination summary statistics and distance functions to achieve this can be very difficult, though, and one usually ends up having to make compromises between the two.</p>
</div>
<div id="abc-rejection-algorithm" class="section level1">
<h1>ABC rejection algorithm</h1>
<p>Lastly, write a function that will return the approximated posterior distribution for theta using the ABC rejection algorithm. We will propose <span class="math inline">\(D_{lat}\)</span> anf <span class="math inline">\(D_{inf}\)</span> from informative priors:</p>
<ul>
<li><span class="math inline">\(D_{lat}\sim\mathcal{Gamma}(shape=16,rate=8)\)</span></li>
<li><span class="math inline">\(D_{inf}\sim\mathcal{Gamma}(shape=16,rate=8)\)</span></li>
</ul>
<p>We choose the Gamma distribution as our parameters must be positive in value. The mean of the gamma distribution is <span class="math inline">\(shape/rate\)</span> and the variance is <span class="math inline">\(shape/rate^2\)</span>. Hence here the mean of the distribution is 2 and the variance is 0.25.</p>
<p>For the sake of simplicity and time, we will assume the remaining parameters are fixed at: R_0 = 2, alpha = 0.9, D_imm = 13, rho = 0.85.</p>
<pre class="r"><code># a function that takes 7 arguments:
# - N :the number of desired samples
# - epsilon: a vector (if the distance function returns a vector) or
#            single number, the tolerance for ABC
# - sumStats: list of summary statistic functions
# - distanceAbc: ABC distance function
# - fitmodel: model to compare to the data
# - initState: initial state for the simulation
# - data: data to compare the model to
my_abcAlgorithm &lt;- function(N, epsilon, sumStats, distanceAbc,
                            fitmodel, initState, data) {
  # set up empty matrix to store results

  # initialise with i = 0

  # while the length of the accepted values (result) is less than the desired length (N)

  # - draw a new d_lat and d_inf from their prior distributions
  #   create a theta vector with the new d_lat and d_inf

  # use computeDistanceAbc to calculate a distance between the model
  # and data

  # if the model distance is within the epsilon window
  # store the accepeted parameter values

  # update i (dimension of results store)

  # return the accepted values
}</code></pre>
<p>If you have trouble filling any of the empty bits in, have a look at our <a href="abc_example.html">more guided example</a>.</p>
<p>Once you have coded this function you can perform some tests to calibrate the tolerances.</p>
<pre class="r"><code>my_abcAlgorithm(
  N = 1000, epsilon = 5,
  sumStats = list(ssMax, ssSize),
  distanceAbc = ssMeanRelDistance,
  fitmodel = seitlStoch,
  initState = initState,
  data = fluTdc1971
)</code></pre>
<p>Again, you can change the list of summary statistics and distance values to some that you have written yourselves, or others from the examples.</p>
<p>You will see that, if your tolerances are too large, you will accept too wide a range of parameter sets. If your tolerances are too small you will have a better approximation of the posterior but very low acceptance rate.</p>
</div>
<div id="going-further-abc-smc-with-two-populations" class="section level1">
<h1>Going further: ABC-SMC with two populations</h1>
<p>The ABC rejection algorithm can be slow and inefficient. An improvement is to resample populations of parameters with decreasing values of tolerance.</p>
<p>Run your function <code>my_abcAlgorithm</code> with a large tolerance for <code>N = 1000</code>. This is your first population (<code>pop_1</code>). From this population, we will randomly sample parameter sets (rows of the matrix), perturb them by a small value and perform the ABC rejection step with a smalller tolerance.</p>
<pre class="r"><code># use the ABC rejection algorithm to find population 1 in the ABC-SMC algorithm

pop_1 &lt;- my_abcAlgorithm(
  N = 1000, epsilon = 10000,
  sumStats = list(ssMax, ssSize),
  distanceAbc = ssMeanRelDistance,
  fitmodel = seitlStoch,
  initState = initState,
  data = fluTdc1971
)

# set up empty matrix to store results of population 2

# initialise with i=0


# while the length of the accepted values (result) is less than the desired length (N)

# - draw a random number between 1 and 1000

# extract corresponding row from pop_1 using this number

# perturb these parameters using multivariate Gaussian distribution

# create a theta vector with the new d_lat and d_inf

# use computeDistanceAbc to calculate a distance between the model
# and data

# if the model distance is within the epsilon window
# store the accepted parameter values

# update i (dimension of results store)

# return the accepted values</code></pre>
<p>Try running the ABC rejection algorithm with a small tolerance and compare the computation time to ABC-SMC with two populations.</p>
<p>If you have trouble filling any of the empty bits in, have a look at our <a href="abc_smc_solution.html">solution</a>.</p>
<p>We can add more populations to the ABC-SMC algorithm described above, but then we will need to calculate ‘weights’ for each parameter set. A <a href="http://rsif.royalsocietypublishing.org/content/6/31/187.short">paper</a> by Toni et al. describes weights for the ABC-SMC algorithm (for deterministic and stochastic models) in detail.</p>
</div>

&nbsp;
<hr />
<p>This web site and the material contained in it were originally created in support of an annual
  short course
  on <a href="https://www.lshtm.ac.uk/study/courses/short-courses/infectious-diseases-dynamics">
  Model Fitting and Inference for Infectious Disease Dynamics</a> at
  the <a href="https://www.lshtm.ac.uk/">London School of Hygiene & Tropical
  Medicine</a>. All material is under
  a <a href="https://github.com/sbfnk/mfiidd/blob/main/LICENSE">MIT
  license</a>. Please report any issues or suggestions for improvement on the
  corresponding <a href="https://github.com/sbfnk/mfiidd/issues">GitHub
  issue tracker</a>. We are always keen to hear about any uses of the material
  here, so please do get touch using the <a href="https://github.com/sbfnk/mfiidd/discussions">Discussion
  board</a> if you have any questions
  or ideas, or if you find the material here useful or use it in your own
  teaching.
</p>

&nbsp;<script data-goatcounter="https://mfiidd.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
